\documentclass[letterpaper]{article}
\usepackage{parskip}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{xfrac}
\usepackage{pgfgantt}

\setlength{\parindent}{0cm}

\begin{document}

\title{CPSC 457 \\ Assignment 4 - Written Component}
\author{Andrew Helwer - 10023875}
\date{December 2012}
\maketitle

\section{OS Structure}

\textbf{Question 1}

Memory accessible by user space programs can be paged out, while kernel memory cannot.
This allows for the benefits of paging without swapping out important memory sections.
It is also a form of sandboxing for user space programs.
Security of the operating system is improved as user space programs do not have privileged access to memory, and are subject to restraints such as Data Execution Prevention.


\textbf{Question 2}

The filesystem is a classic example. 
It's a very low-level structure, but is still accessible and manipulable by users through a GUI or CLI.

\section{Processes and Threads}

\textbf{Question 1}

In user-level threads, each thread has its own stack.
This is necessary as each thread may call and return from functions independently.
Each kernel-level threads also has its own stack, which holds the stack of whichever user-level thread is excecuting on it at the time.
The contents of this stack are swapped out as threads are swapped at the user level.

\textbf{Question 2}

The expected length of time for each request is $E(x) = \sfrac{1}{3} \times 75 \text{ms} + \sfrac{2}{3} \times 15 \text{ms} = 35 \text{ms}$.
Thus a single-threaded server can serve $1000 \text{ms} / 35 \text{ms} = 28 \text{ req/s}$.
Assuming perfect scaling, a multithreaded server with $n$ threads can serve $n \times 28$ requests every second.

\textbf{Question 3}

Busy waiting is when a thread enters an infinite loop, repeatedly checking some condition until it is satisfied at which point it exits the loop and progresses.
Busy waiting can be avoided by having the thread wait on a conditional variable.

\textbf{Question 4}

Since wait() unlocks a locked mutex before waiting on a condition variable, and signal() wakes up threads waiting on the variable and has them lock the mutex, if they are not executed atomically mutual exclusion can be violated.
Assume thread $A$ locks mutex $M$ then calls wait() with mutex $M$ and condition variable $C$.
This causes thread $A$ to unlock mutex $M$.
Before thread $A$ can reach the state of waiting on $C$, thread $B$ acquires a lock on mutex $M$ and enters a critical section.

\section{CPU Scheduling}

\textbf{Question 1}

\textbf{Question 2}

Preemptive scheduling will possibly stop a task before it has finished execution in order to allow execution of a different task.
Nonpreemptive scheduling will allow any task which has begun execution to reach completion.

\textbf{Question 3}

\begin{figure}[ftbp]
\begin{center}

\begin{ganttchart}[y unit title=0.4cm,
y unit chart=0.5cm,
vgrid,hgrid, 
title label anchor/.style={below=-1.6ex},
title left shift=.05,
title right shift=-.05,
title height=1,
bar/.style={fill=gray!50},
incomplete/.style={fill=white},
progress label text={},
bar height=0.7,
group right shift=0,
group top shift=.6,
group height=.3,
group peaks={}{}{.2}]{19}
%labels
\gantttitle{0}{1} 
\gantttitle{1}{1} 
\gantttitle{2}{1} 
\gantttitle{3}{1} 
\gantttitle{4}{1} 
\gantttitle{5}{1} 
\gantttitle{6}{1} 
\gantttitle{7}{1} 
\gantttitle{8}{1} 
\gantttitle{9}{1} 
\gantttitle{10}{1} 
\gantttitle{11}{1} 
\gantttitle{12}{1} 
\gantttitle{13}{1} 
\gantttitle{14}{1} 
\gantttitle{15}{1} 
\gantttitle{16}{1} 
\gantttitle{17}{1} 
\gantttitle{18}{1} \\

%tasks
\ganttbar{$P_1$}{1}{1} \ganttbar{$P_1$}{3}{3} \ganttbar{$P_1$}{7}{14} \\
\ganttbar{$P_2$}{2}{2} \\
\ganttbar{$P_3$}{4}{5} \\
\ganttbar{$P_4$}{6}{6} \\
\ganttbar{$P_5$}{15}{19} \\

%relations 
\ganttlink{elem0}{elem3} 
\ganttlink{elem3}{elem1} 
\ganttlink{elem1}{elem4} 
\ganttlink{elem4}{elem5} 
\ganttlink{elem5}{elem2} 
\ganttlink{elem2}{elem6} 
\end{ganttchart}
\end{center}
\caption{Task Execution Gantt Chart - SRTN}
\end{figure}

See Figure 1 for the Gantt Chart.
The average waiting time is 1.8 ms.

\textbf{Question 4}

\begin{figure}[ftbp]
\begin{center}

\begin{ganttchart}[y unit title=0.4cm,
y unit chart=0.5cm,
vgrid,hgrid, 
title label anchor/.style={below=-1.6ex},
title left shift=.05,
title right shift=-.05,
title height=1,
bar/.style={fill=gray!50},
incomplete/.style={fill=white},
progress label text={},
bar height=0.7,
group right shift=0,
group top shift=.6,
group height=.3,
group peaks={}{}{.2}]{19}
%labels
\gantttitle{0}{1} 
\gantttitle{1}{1} 
\gantttitle{2}{1} 
\gantttitle{3}{1} 
\gantttitle{4}{1} 
\gantttitle{5}{1} 
\gantttitle{6}{1} 
\gantttitle{7}{1} 
\gantttitle{8}{1} 
\gantttitle{9}{1} 
\gantttitle{10}{1} 
\gantttitle{11}{1} 
\gantttitle{12}{1} 
\gantttitle{13}{1} 
\gantttitle{14}{1} 
\gantttitle{15}{1} 
\gantttitle{16}{1} 
\gantttitle{17}{1} 
\gantttitle{18}{1} \\

%tasks
\ganttbar{$P_1$}{1}{1} \ganttbar{$P_1$}{3}{3} \ganttbar{$P_1$}{5}{5} \ganttbar{$P_1$}{1}{1} 
\ganttbar{$P_1$}{8}{9} 
\ganttbar{$P_1$}{11}{11} 
\ganttbar{$P_1$}{13}{13} 
\ganttbar{$P_1$}{15}{15} 
\ganttbar{$P_1$}{17}{17} 
\ganttbar{$P_1$}{19}{19} \\
\ganttbar{$P_2$}{2}{2} \\
\ganttbar{$P_3$}{4}{4} \ganttbar{$P_3$}{7}{7} \\
\ganttbar{$P_4$}{6}{6} \\

\ganttbar{$P_5$}{10}{10} 
\ganttbar{$P_5$}{12}{12} 
\ganttbar{$P_5$}{14}{14} 
\ganttbar{$P_5$}{16}{16} 
\ganttbar{$P_5$}{18}{18} \\

%relations 
%\ganttlink{elem4}{elem6} 
\end{ganttchart}
\end{center}
\caption{Task Execution Gantt Chart - RR}
\end{figure}

See Figure 2 for the Gantt Chart.
There are 17 context switches.

\textbf{Question 5}

\begin{figure}[ftbp]
\begin{center}

\begin{ganttchart}[y unit title=0.4cm,
y unit chart=0.5cm,
vgrid,hgrid, 
title label anchor/.style={below=-1.6ex},
title left shift=.05,
title right shift=-.05,
title height=1,
bar/.style={fill=gray!50},
incomplete/.style={fill=white},
progress label text={},
bar height=0.7,
group right shift=0,
group top shift=.6,
group height=.3,
group peaks={}{}{.2}]{19}
%labels
\gantttitle{0}{1} 
\gantttitle{1}{1} 
\gantttitle{2}{1} 
\gantttitle{3}{1} 
\gantttitle{4}{1} 
\gantttitle{5}{1} 
\gantttitle{6}{1} 
\gantttitle{7}{1} 
\gantttitle{8}{1} 
\gantttitle{9}{1} 
\gantttitle{10}{1} 
\gantttitle{11}{1} 
\gantttitle{12}{1} 
\gantttitle{13}{1} 
\gantttitle{14}{1} 
\gantttitle{15}{1} 
\gantttitle{16}{1} 
\gantttitle{17}{1} 
\gantttitle{18}{1} \\

%tasks
\ganttbar{$P_1$}{1}{2} \ganttbar{$P_1$}{4}{7} \ganttbar{$P_1$}{9}{12} \\
\ganttbar{$P_2$}{3}{3} \\
\ganttbar{$P_3$}{18}{19} \\
\ganttbar{$P_4$}{8}{8} \\
\ganttbar{$P_5$}{13}{17} \\

%relations 
%\ganttlink{elem4}{elem6} 
\end{ganttchart}
\end{center}
\caption{Task Execution Gantt Chart - Multilevel}
\end{figure}

See Figure 3 for Gantt Chart.

\section{Deadlock}

\textbf{Question 1}

\section{Memory}

\textbf{Question 1}

\textbf{Question 2}

\textbf{Question 3}

\textbf{Question 4}

\textbf{Question 5}

\textbf{Question 6}

\textbf{Question 7}

\section{File System}

\textbf{Question 1}

\textbf{Question 2}

\textbf{Question 3}

\end{document}

