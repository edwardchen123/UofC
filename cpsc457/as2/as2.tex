\documentclass[letterpaper]{article}

\begin{document}

\title{CPSC 457 \\ Assignment 2 - Written Component}
\author{Andrew Helwer - 10023875}
\date{October 2012}
\maketitle

\section{Question 1}

When a thread is created, it requires four things: a call stack, an Instruction Pointer, a Stack Pointer, and an entry in the OS scheduler.
The call stack is allocated somewhere on the heap in user space, while the Instruction Pointer, Stack Pointer, and scheduler entry are registered in kernel space via calls to the OS API.
When a process is created, it is granted access to the complete paging memory space (0x0 to 0xffffffffffffffff).
As memory is used by the process, pages of memory become backed by physical hardware.
The address space granted to the process is its own, and is not shared with other entities (strictly speaking).
Details of a new process are stored in the Process Control Block.

\section{Question 2}

Context switching is an action taking by the operating system to store the state of an entity currently executing on a processor core.
The OS then loads a different entity for execution on the core.
For threads, this involves only storing the Instruction and Stack Pointers then loading the Instruction and Stack Pointers from a different thread.
For processes, the Process Control Block must be stored in kernel memory, with another PCB loaded in its stead.

\section{Question 3}

The biggest advantage of implementing threads in the user space is lower per-entity overhead.
The biggest disadvantage is that one thread crashing takes down all threads in the process with it.

\section{Question 4}

If both functions attempt to modify the shared value of \$1000 concurrently, it is possible that the value will be corrupted and the balance information lost.
This is easily avoided by serializing operations on the account balance, either through the use of mutexes or with a thread-safe operation queue.

\end{document}
